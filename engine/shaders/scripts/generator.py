import os
import pathlib
import argparse
import reflection
import datetime
import shaders

MAX_SETS = 4
LANG_VK = "vk450"
LANG_GL = "gl410"
LANGS = [LANG_VK, LANG_GL]
PREFIX = "auto_"
DATETIME = datetime.datetime.now()
DIR_ROOT = pathlib.Path(__file__).parent.parent.parent.parent
DIR_SHADERS = pathlib.Path(__file__).parent.parent
DIR_GENERATED = DIR_SHADERS / "generated"
SIGNATURE = f"// Autogenerated file by 'generator.py' on {DATETIME}, do not modify\n"
CXX_PRAGMA = "#pragma once\n"
CXX_NAMESPACE = "wmoge"
CXX_INCLUDES = (
    '#include "core/string_id.hpp"\n'
    '#include "core/string_utf.hpp"\n'
    '#include "core/string_utils.hpp"\n'
    '#include "gfx/gfx_defs.hpp"\n'
    '#include "math/vec.hpp"\n'
    '#include "math/mat.hpp"\n'
)

LICENSE_HEADER = (
    "/**********************************************************************************/\n"
    "/* Wmoge game engine                                                              */\n"
    "/* Available at github https://github.com/EgorOrachyov/wmoge                      */\n"
    "/**********************************************************************************/\n"
    "/* MIT License                                                                    */\n"
    "/*                                                                                */\n"
    "/* Copyright (c) 2023 Egor Orachyov                                               */\n"
    "/*                                                                                */\n"
    "/* Permission is hereby granted, free of charge, to any person obtaining a copy   */\n"
    '/* of this software and associated documentation files (the "Software"), to deal  */\n'
    "/* in the Software without restriction, including without limitation the rights   */\n"
    "/* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      */\n"
    "/* copies of the Software, and to permit persons to whom the Software is          */\n"
    "/* furnished to do so, subject to the following conditions:                       */\n"
    "/*                                                                                */\n"
    "/* The above copyright notice and this permission notice shall be included in all */\n"
    "/* copies or substantial portions of the Software.                                */\n"
    "/*                                                                                */\n"
    '/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     */\n'
    "/* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       */\n"
    "/* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    */\n"
    "/* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         */\n"
    "/* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  */\n"
    "/* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  */\n"
    "/* SOFTWARE.                                                                      */\n"
    "/**********************************************************************************/\n"
)

SHADERS_LIST = shaders.SHADERS_LIST


def make_shader_name(shader_file, lang):
    left, right = shader_file.split(".")
    return f"{left}_{lang}_{right}"


def make_shader_source_name(shader_file, lang):
    return f"source_{make_shader_name(shader_file, lang)}"


def make_file_name_only(shader_file, lang, extension):
    return f"{PREFIX}{make_shader_name(shader_file, lang)}.{extension}"


def make_file_name(shader_file, lang, directory, extension):
    return directory / make_file_name_only(shader_file, lang, extension)


class CodeGenerator:
    def __init__(self, shader):
        self.shader = shader

    def emit_sampler(self, sampler):
        raise Exception("not implemented")

    def emit_image(self, image):
        raise Exception("not implemented")

    def emit_const(self, const):
        raise Exception("not implemented")

    def emit_type_decl(self, element):
        raise Exception("not implemented")

    def emit_struct(self, struct):
        raise Exception("not implemented")

    def emit_buffer(self, buffer):
        raise Exception("not implemented")

    def emit(self, element):
        if isinstance(element, reflection.Sampler):
            return self.emit_sampler(element)
        if isinstance(element, reflection.Image):
            return self.emit_image(element)
        if isinstance(element, reflection.Constant):
            return self.emit_const(element)
        if isinstance(element, reflection.Struct):
            return self.emit_struct(element)
        if isinstance(element, reflection.Buffer):
            return self.emit_buffer(element)
        return ""

    def run(self):
        result = ""

        for struct in self.shader.structs:
            result += self.emit_struct(struct)
            result += "\n"

        result += "\n"

        for const in self.shader.constants:
            result += self.emit_const(const)
            result += "\n"

        result += "\n"

        for sampler in self.shader.samplers:
            result += self.emit_sampler(sampler)
            result += "\n"

        result += "\n"

        for image in self.shader.images:
            result += self.emit_image(image)
            result += "\n"

        result += "\n"

        for buffer in self.shader.buffers:
            result += self.emit_buffer(buffer)
            result += "\n"

        return result


class CodeGeneratorGlsl(CodeGenerator):
    def __init__(self, shader):
        super().__init__(shader)

    def sampler_layout(self, binding):
        raise Exception("not implemented")

    def image_layout(self, binding, format):
        raise Exception("not implemented")

    def buffer_layout(self, binding, layout):
        raise Exception("not implemented")

    def emit_sampler(self, sampler):
        assert isinstance(sampler, reflection.Sampler)

        return (
            self.sampler_layout(sampler.binding)
            + f"uniform {sampler.decl_type.name} {sampler.name};\n"
        )

    def emit_image(self, image):
        assert isinstance(image, reflection.Image)

        return (
            self.image_layout(image.binding, image.format)
            + f"uniform {image.qualifier} {image.decl_type.name} {image.name};\n"
        )

    def emit_const(self, const):
        assert isinstance(const, reflection.Constant)

        return f"#define {const.name} ({const.value})"

    def emit_type_decl(self, element):
        if element == reflection.TYPE_FLOAT:
            return "float"
        if element == reflection.TYPE_INT:
            return "int"
        if element == reflection.TYPE_UINT:
            return "uint"
        if element == reflection.TYPE_VEC2:
            return "vec2"
        if element == reflection.TYPE_VEC3:
            return "vec3"
        if element == reflection.TYPE_VEC4:
            return "vec4"
        if element == reflection.TYPE_IVEC2:
            return "ivec2"
        if element == reflection.TYPE_IVEC3:
            return "ivec3"
        if element == reflection.TYPE_IVEC4:
            return "ivec4"
        if element == reflection.TYPE_UVEC2:
            return "uvec2"
        if element == reflection.TYPE_UVEC3:
            return "uvec3"
        if element == reflection.TYPE_UVEC4:
            return "uvec4"
        if element == reflection.TYPE_MAT2:
            return "mat2"
        if element == reflection.TYPE_MAT3:
            return "mat3"
        if element == reflection.TYPE_MAT4:
            return "mat4"
        if isinstance(element, reflection.Struct):
            return f"{element.name}"
        return ""

    def emit_struct(self, struct):
        assert isinstance(struct, reflection.Struct)

        generated = f"struct {struct.name}" "{\n"

        for field in struct.fields:
            generated += f"{self.emit_type_decl(field.decl_type)} {field.name}"
            generated += field.array_str() + ";\n"

        generated += "};\n"

        return generated

    def emit_buffer(self, buffer):
        assert isinstance(buffer, reflection.Buffer)

        generated = (
            self.buffer_layout(buffer.binding, buffer.layout)
            + f"{buffer.keyword} {buffer.name} "
            "{\n"
        )

        for field in buffer.struct.fields:
            generated += f"{self.emit_type_decl(field.decl_type)} {field.name}"
            generated += field.array_str() + ";\n"

        generated += "};\n"

        return generated


class CodeGeneratorGlslVk450(CodeGeneratorGlsl):
    def __init__(self, shader):
        super().__init__(shader)

    def sampler_layout(self, binding):
        return f"layout (set = {binding.set_num}, binding = {binding.slot_num}) "

    def image_layout(self, binding, format):
        return (
            f"layout (set = {binding.set_num}, binding = {binding.slot_num}, {format}) "
        )

    def buffer_layout(self, binding, layout):
        return (
            f"layout (set = {binding.set_num}, binding = {binding.slot_num}, {layout}) "
        )


class CodeGeneratorGlslGl410(CodeGeneratorGlsl):
    def __init__(self, shader):
        super().__init__(shader)

    def sampler_layout(self, binding):
        return f""

    def image_layout(self, binding, format):
        return f"layout ({format}) "

    def buffer_layout(self, binding, layout):
        return f"layout ({layout}) "


class CodeGeneratorCxx(CodeGenerator):
    def __init__(self, shader):
        super().__init__(shader)

    def emit_sampler(self, sampler):
        assert isinstance(sampler, reflection.Sampler)

        name = sampler.name.upper()
        binding = sampler.binding
        return (
            f"static constexpr const int {name}_SET = {binding.set_num};\n"
            f"static constexpr const int {name}_SLOT = {binding.slot_num};\n"
            f"static constexpr const auto {name}_LOC = {binding.to_gfx_loc()};\n"
            f'static constexpr const char {name}_NAME[] = "{sampler.name}";\n'
        )

    def emit_image(self, image):
        assert isinstance(image, reflection.Image)

        name = image.name.upper()
        binding = image.binding
        return (
            f"static constexpr const int {name}_SET = {binding.set_num};\n"
            f"static constexpr const int {name}_SLOT = {binding.slot_num};\n"
            f"static constexpr const auto {name}_LOC = {binding.to_gfx_loc()};\n"
            f'static constexpr const char {name}_NAME[] = "{image.name}";\n'
            f'static constexpr const char {name}_FORMAT[] = "{image.format}";\n'
            f'static constexpr const char {name}_QUALIFIER[] = "{image.qualifier}";\n'
        )

    def emit_const(self, const):
        assert isinstance(const, reflection.Constant)

        return f"static constexpr const auto {const.name.upper()} = {const.value};"

    def emit_type_decl(self, element):
        if element == reflection.TYPE_FLOAT:
            return "float"
        if element == reflection.TYPE_INT:
            return "int"
        if element == reflection.TYPE_UINT:
            return "unsigned int"
        if element == reflection.TYPE_VEC2:
            return "Vec2f"
        if element == reflection.TYPE_VEC3:
            return "Vec3f"
        if element == reflection.TYPE_VEC4:
            return "Vec4f"
        if element == reflection.TYPE_IVEC2:
            return "Vec2i"
        if element == reflection.TYPE_IVEC3:
            return "Vec3i"
        if element == reflection.TYPE_IVEC4:
            return "Vec4i"
        if element == reflection.TYPE_UVEC2:
            return "Vec2u"
        if element == reflection.TYPE_UVEC3:
            return "Vec3u"
        if element == reflection.TYPE_UVEC4:
            return "Vec4u"
        if element == reflection.TYPE_MAT2:
            return "Mat2x2f"
        if element == reflection.TYPE_MAT3:
            return "Mat3x3f"
        if element == reflection.TYPE_MAT4:
            return "Mat4x4f"
        if isinstance(element, reflection.Struct):
            return f"struct {element.name}"
        return ""

    def emit_struct(self, struct):
        assert isinstance(struct, reflection.Struct)

        generated = f"struct {struct.name}" "{\n"

        for field in struct.fields:
            if field.is_unbound_array():
                generated += "/* "

            generated += f"{self.emit_type_decl(field.decl_type)} {field.name}"
            generated += field.array_str_cpp()

            if field.is_unbound_array():
                generated += "; */\n"
            else:
                generated += ";\n"

        generated += "};\n"

        return generated

    def emit_buffer(self, buffer):
        assert isinstance(buffer, reflection.Buffer)

        buffer_structure = self.emit_struct(buffer.struct) + "\n"

        name = buffer.name.upper()
        binding = buffer.binding
        buffer_info = (
            f"static constexpr const int {name}_SET = {binding.set_num};\n"
            f"static constexpr const int {name}_SLOT = {binding.slot_num};\n"
            f"static constexpr const auto {name}_LOC = {binding.to_gfx_loc()};\n"
            f'static constexpr const char {name}_NAME[] = "{buffer.name}";\n'
        )

        return buffer_structure + buffer_info


class CodeGeneratorPass:
    def __init__(self, shader, langs):
        self.shader = shader
        self.langs = langs

    def emit_name(self):
        return (
            f"StringId get_name() override "
            "{"
            f'return SID("{self.shader.name}");'
            "}\n"
        )

    def emit_layouts(self):
        sources = ""

        sources += "void fill_layout(GfxDescSetLayoutDescs& layouts_desc, Shader* shader) override {\n"

        for set_num in range(MAX_SETS):
            resources = self.shader.set_resources(set_num)

            if self.shader.material_set and set_num == self.shader.material_set:
                assert len(resources) == 0

                sources += f"// fill set num = {set_num}" "\n"
                sources += "if (shader) {\n"
                sources += "auto& layout = layouts_desc.emplace_back();\n"
                sources += "shader->fill_layout(layout);"
                sources += "}\n"
                continue

            if len(resources) > 0:
                sources += f"// fill set num = {set_num}" "\n"
                sources += "{\n"
                sources += "auto& layout = layouts_desc.emplace_back();\n"

                var = ""
                resource_type = ""

                for resource in resources:
                    if isinstance(resource, reflection.Sampler):
                        var = f"binding_{resource.name}"
                        resource_type = "SampledTexture"
                    if isinstance(resource, reflection.Image):
                        var = f"binding_{resource.name}"
                        resource_type = "StorageImage"
                    if isinstance(resource, reflection.UniformBuffer):
                        var = f"binding_{resource.name}"
                        resource_type = "UniformBuffer"
                    if isinstance(resource, reflection.StorageBuffer):
                        var = f"binding_{resource.name}"
                        resource_type = "StorageBuffer"

                    sources += f"auto& {var} = layout.emplace_back();\n"
                    sources += f"{var}.name = " f'SID("{resource.name}");\n'
                    sources += f"{var}.binding = {resource.binding.slot_num};\n"
                    sources += f"{var}.count = {1};\n"
                    sources += f"{var}.type = GfxBindingType::{resource_type};\n"

                sources += "}\n"
                continue

        sources += "}\n"

        return sources

    def emit_reload(self, name, filter_string):
        sources = ""

        files = self.shader.filter_files(filter_string)

        if len(files) > 0:
            file = files[0]

            for i, lang in enumerate(self.langs):
                file_name = '"' f"{make_file_name_only(file, lang, 'glsl')}" '"'
                file_path = "folder + '/' + " + file_name

                sources += f"// lang is {lang}\n"
                sources += "{\n"
                sources += f"const auto file_path = {file_path};\n"
                sources += (
                    f"if (file_system->read_file(file_path, m_{name}[{i}]))" "{\n"
                )
                sources += (
                    "WG_LOG_INFO(" f'"reload shader from file " << file_path' ");"
                )
                sources += "}\n"
                sources += "}\n"

        return sources

    def emit_reloads(self):
        sources = ""

        sources += (
            "Status reload_sources(const std::string& folder, FileSystem* file_system) override "
            "{\n"
        )
        sources += self.emit_reload("vertex", "vert")
        sources += self.emit_reload("fragment", "frag")
        sources += self.emit_reload("compute", "comp")
        sources += "return StatusCode::Ok;\n"
        sources += "}\n"

        return sources

    def emit_source(self, name, filter_string):
        sources = ""
        sources += (
            f"const std::string& get_{name}(GfxShaderLang lang) override"
            "{"
            f"return m_{name}[int(lang)];"
            "}\n"
        )
        sources += f"std::string m_{name}[{len(self.langs)}]"

        files = self.shader.filter_files(filter_string)

        if len(files) > 0:
            file = files[0]
            sources += "={"
            sources += ",".join(
                [make_shader_source_name(file, lang) for lang in self.langs]
            )
            sources += "}"

        sources += ";\n"
        return sources

    def emit_sources(self):
        sources = ""

        sources += self.emit_source("vertex", "vert")
        sources += self.emit_source("fragment", "frag")
        sources += self.emit_source("compute", "comp")

        return sources

    def emit(self):
        sources = ""

        sources += (
            f"   /** @brief Auto generated pass for '{self.shader.name}' shader */\n"
        )
        sources += f"class ShaderPass{self.shader.cls} final : public ShaderPass" "{\n"
        sources += f"public:" "\n"
        sources += f"ShaderPass{self.shader.cls}() = default;" "\n"
        sources += f"~ShaderPass{self.shader.cls}() override = default;" "\n"

        sources += self.emit_name()
        sources += self.emit_layouts()
        sources += self.emit_reloads()
        sources += self.emit_sources()

        sources += "};\n"

        return sources


def read_file(file_path):
    with open(file_path, "r") as file:
        return file.readlines()


def process_file(file_path, included):
    content = read_file(DIR_SHADERS / file_path)
    output = []

    for line in content:
        if line == "\n":
            continue
        if line.startswith("/*"):
            continue
        if line.startswith("#version"):
            continue
        if line.startswith("#include "):
            include_file = (
                line.replace("#include ", "").replace('"', "").replace("\n", "")
            )
            if include_file not in included:
                included.add(include_file)
                output += process_file(include_file, included)
            continue

        output.append(line)

    output.append("\n")
    return output


def process_general(generator, shader, lang, dir_build):
    for shader_file in shader.files:
        generated_code = ""

        if shader.material_set:
            generated_code += f"#define MATERIAL_SET {shader.material_set}\n"

        generated_code += generator.run()
        generated_code += "\n"
        generated_code += "".join(process_file(shader_file, set()))

        with open(make_file_name(shader_file, lang, DIR_GENERATED, "hpp"), "w") as file:
            file.write(LICENSE_HEADER)
            file.write("\n")
            file.write(SIGNATURE)
            file.write("\n")
            file.write(CXX_PRAGMA)
            file.write("\n")
            file.write(CXX_INCLUDES)
            file.write("\n")
            file.write(f"namespace {CXX_NAMESPACE}" "{\n")
            file.write("\n")
            file.write(
                f'static const char {make_shader_source_name(shader_file, lang)}[] = R"(\n'
            )
            file.write(generated_code)
            file.write('\n)";\n')
            file.write("}\n")

        if dir_build:
            with open(
                make_file_name(shader_file, lang, dir_build, "glsl"), "w"
            ) as file:
                file.write(generated_code)


def process_vk(shader, dir_build):
    process_general(CodeGeneratorGlslVk450(shader), shader, LANG_VK, dir_build)


def process_gl(shader, dir_build):
    process_general(CodeGeneratorGlslGl410(shader), shader, LANG_GL, dir_build)


def process_cxx_reflection(shader):
    with open(DIR_GENERATED / f"{PREFIX}{shader.name}_reflection.hpp", "w") as file:
        file.write(LICENSE_HEADER)
        file.write("\n")
        file.write(SIGNATURE)
        file.write("\n")
        file.write(CXX_PRAGMA)
        file.write("\n")
        file.write(CXX_INCLUDES)
        file.write("\n")
        file.write(f"namespace {CXX_NAMESPACE}" "{\n")
        file.write("\n")
        file.write(
            f"/** @brief Auto generated reflection for '{shader.name}' shader */\n"
        )
        file.write(f"struct Shader{shader.cls}" "{\n")
        file.write(f'static constexpr const char NAME[] = "{shader.name}";\n')
        file.write(f'static constexpr const char CLS[] = "{shader.cls}";\n')
        file.write(f"static constexpr int NUM_FILES = {int(len(shader.files))};\n")
        file.write(f"static constexpr int NUM_CONSTS = {int(len(shader.constants))};\n")
        file.write(
            f"static constexpr int NUM_SAMPLERS = {int(len(shader.samplers))};\n"
        )
        file.write(f"static constexpr int NUM_BUFFERS = {int(len(shader.buffers))};\n")
        file.write("\n")
        file.write(CodeGeneratorCxx(shader).run())
        file.write("};\n\n")
        file.write("}\n")


def process_cxx_pass(shader):
    if len(shader.files) == 0:
        return

    with open(DIR_GENERATED / f"{PREFIX}{shader.name}_pass.hpp", "w") as file:
        file.write(LICENSE_HEADER)
        file.write("\n")
        file.write(SIGNATURE)
        file.write("\n")
        file.write(CXX_PRAGMA)
        file.write("\n")
        file.write(CXX_INCLUDES)
        file.write('#include "render/shader_pass.hpp"\n')
        file.write("\n")

        for lang in LANGS:
            for shader_file in shader.files:
                file.write(
                    f'#include "'
                    f"{make_file_name_only(shader_file, lang, 'hpp')}"
                    '"\n'
                )

        file.write("\n")
        file.write(f"namespace {CXX_NAMESPACE}" "{\n")
        file.write(CodeGeneratorPass(shader, LANGS).emit())
        file.write("}\n")


def process_cxx(shader):
    process_cxx_reflection(shader)
    process_cxx_pass(shader)


def main():
    parser = argparse.ArgumentParser("Reflection generator for engine shader files")
    parser.add_argument(
        "--mode", help="what to generate (all,vk,gl,cxx)", default="all"
    )
    parser.add_argument(
        "--build",
        help="path to a build of project to output shaders for hot-reload_shaders",
        default=None,
    )
    args = parser.parse_args()

    dir_build = None
    to_generate = ["vk", "gl", "cxx"] if "all" in args.mode else args.mode.split(",")
    print(f"generate for {to_generate}")

    os.makedirs(DIR_GENERATED, exist_ok=True)
    print(f"output generated shaders for engine into {DIR_GENERATED}")

    if args.build:
        dir_build = DIR_ROOT / args.build / "shaders"
        os.makedirs(dir_build, exist_ok=True)
        print(f"output generated shaders for hot-reload_shaders to {dir_build}")

    for i, shader in enumerate(SHADERS_LIST):
        print(f"[{i + 1}/{len(SHADERS_LIST)}] process shader {shader.name}")

        if "vk" in to_generate:
            process_vk(shader, dir_build)
        if "gl" in to_generate:
            process_gl(shader, dir_build)
        if "cxx" in to_generate:
            process_cxx(shader)


if __name__ == "__main__":
    main()

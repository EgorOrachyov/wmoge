import os
import pathlib
import argparse
import reflection
import datetime
import shaders

PREFIX = 'auto_'
DATETIME = datetime.datetime.now()
DIR_ROOT = pathlib.Path(__file__).parent.parent.parent
DIR_SHADERS = pathlib.Path(__file__).parent
DIR_GENERATED = DIR_SHADERS / 'generated'
SIGNATURE = f"// Autogenerated file by 'generator.py' on {DATETIME}, do not modify\n"
CXX_PRAGMA = '#pragma once\n'
CXX_NAMESPACE = 'wmoge'
CXX_INCLUDES = \
    '#include "core/string_id.hpp"\n' \
    '#include "core/string_utf.hpp"\n' \
    '#include "core/string_utils.hpp"\n' \
    '#include "gfx/gfx_defs.hpp"\n' \
    '#include "math/vec.hpp"\n' \
    '#include "math/mat.hpp"\n'

LICENSE_HEADER = \
    '/**********************************************************************************/\n' \
    '/* Wmoge game engine                                                              */\n' \
    '/* Available at github https://github.com/EgorOrachyov/wmoge                      */\n' \
    '/**********************************************************************************/\n' \
    '/* MIT License                                                                    */\n' \
    '/*                                                                                */\n' \
    '/* Copyright (c) 2023 Egor Orachyov                                               */\n' \
    '/*                                                                                */\n' \
    '/* Permission is hereby granted, free of charge, to any person obtaining a copy   */\n' \
    '/* of this software and associated documentation files (the "Software"), to deal  */\n' \
    '/* in the Software without restriction, including without limitation the rights   */\n' \
    '/* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell      */\n' \
    '/* copies of the Software, and to permit persons to whom the Software is          */\n' \
    '/* furnished to do so, subject to the following conditions:                       */\n' \
    '/*                                                                                */\n' \
    '/* The above copyright notice and this permission notice shall be included in all */\n' \
    '/* copies or substantial portions of the Software.                                */\n' \
    '/*                                                                                */\n' \
    '/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR     */\n' \
    '/* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,       */\n' \
    '/* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE    */\n' \
    '/* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER         */\n' \
    '/* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  */\n' \
    '/* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  */\n' \
    '/* SOFTWARE.                                                                      */\n' \
    '/**********************************************************************************/\n'

SHADERS_LIST = shaders.SHADERS_LIST


class CodeGenerator:
    def __init__(self, shader):
        self.shader = shader

    def emit_sampler(self, sampler):
        raise Exception('not implemented')

    def emit_const(self, const):
        raise Exception('not implemented')

    def emit_type_decl(self, element):
        raise Exception('not implemented')

    def emit_struct(self, struct):
        raise Exception('not implemented')

    def emit_buffer(self, buffer):
        raise Exception('not implemented')

    def emit(self, element):
        if isinstance(element, reflection.Sampler):
            return self.emit_sampler(element)
        if isinstance(element, reflection.Constant):
            return self.emit_const(element)
        if isinstance(element, reflection.Struct):
            return self.emit_struct(element)
        if isinstance(element, reflection.Buffer):
            return self.emit_buffer(element)
        return ""

    def run(self):
        result = ""

        for const in self.shader.constants:
            result += self.emit_const(const)
            result += '\n'

        for sampler in self.shader.samplers:
            result += self.emit_sampler(sampler)
            result += '\n'

        for buffer in self.shader.buffers:
            result += self.emit_buffer(buffer)
            result += '\n'

        return result


class CodeGeneratorGlsl(CodeGenerator):
    def __init__(self, shader):
        super().__init__(shader)

    def sampler_layout(self, binding):
        raise Exception('not implemented')

    def buffer_layout(self, binding, layout):
        raise Exception('not implemented')

    def emit_sampler(self, sampler):
        assert isinstance(sampler, reflection.Sampler)

        return self.sampler_layout(sampler.binding) + f"uniform {sampler.decl_type.name} {sampler.name};\n"

    def emit_const(self, const):
        assert isinstance(const, reflection.Constant)

        return f"#define {const.name} ({const.value})\n"

    def emit_type_decl(self, element):
        if element == reflection.TYPE_FLOAT:
            return "float"
        if element == reflection.TYPE_INT:
            return "int"
        if element == reflection.TYPE_UINT:
            return "uint"
        if element == reflection.TYPE_VEC2:
            return "vec2f"
        if element == reflection.TYPE_VEC3:
            return "vec3f"
        if element == reflection.TYPE_VEC4:
            return "vec4f"
        if element == reflection.TYPE_IVEC2:
            return "vec2i"
        if element == reflection.TYPE_IVEC3:
            return "vec3i"
        if element == reflection.TYPE_IVEC4:
            return "vec4i"
        if element == reflection.TYPE_UVEC2:
            return "vec2u"
        if element == reflection.TYPE_UVEC3:
            return "vec3u"
        if element == reflection.TYPE_UVEC4:
            return "vec4u"
        if element == reflection.TYPE_MAT2:
            return "mat2"
        if element == reflection.TYPE_MAT3:
            return "mat3"
        if element == reflection.TYPE_MAT4:
            return "mat4"
        if isinstance(element, reflection.Struct):
            return f"struct {element.name}"
        return ""

    def emit_struct(self, struct):
        assert isinstance(struct, reflection.Struct)

        generated = f"struct {struct.name}""{\n"

        for field in struct.fields:
            generated += f"{self.emit_type_decl(field.decl_type)} {field.name}"
            generated += f"[{field.array_size}];\n" if field.is_array() else ";\n"

        generated += "};\n"

        return generated

    def emit_buffer(self, buffer):
        assert isinstance(buffer, reflection.Buffer)

        generated = self.buffer_layout(buffer.binding, buffer.layout) + f"{buffer.keyword} {buffer.name} ""{\n"

        for field in buffer.struct.fields:
            generated += f"{self.emit_type_decl(field.decl_type)} {field.name}"
            generated += f"[{field.array_size}];\n" if field.is_array() else ";\n"

        generated += "};\n"

        return generated


class CodeGeneratorGlslVk450(CodeGeneratorGlsl):
    def __init__(self, shader):
        super().__init__(shader)

    def sampler_layout(self, binding):
        return f"layout (set = {binding.set_num}, binding = {binding.slot_num}) "

    def buffer_layout(self, binding, layout):
        return f"layout (set = {binding.set_num}, binding = {binding.slot_num}, {layout}) "


class CodeGeneratorGlslGl410(CodeGeneratorGlsl):
    def __init__(self, shader):
        super().__init__(shader)

    def sampler_layout(self, binding):
        return f""

    def buffer_layout(self, binding, layout):
        return f"layout ({layout}) "


class CodeGeneratorCxx(CodeGenerator):
    def __init__(self, shader):
        super().__init__(shader)

    def emit_sampler(self, sampler):
        assert isinstance(sampler, reflection.Sampler)

        name = sampler.name.upper()
        binding = sampler.binding
        return f"static constexpr const int {name}_SET = {binding.set_num};\n" \
               f"static constexpr const int {name}_SLOT = {binding.slot_num};\n" \
               f"static constexpr const auto {name}_LOC = {binding.to_gfx_loc()};\n" \
               f"static constexpr const char {name}_NAME[] = \"{sampler.name}\";\n"

    def emit_const(self, const):
        assert isinstance(const, reflection.Constant)

        return f"static constexpr const auto {const.name.upper()} = {const.value};\n"

    def emit_type_decl(self, element):
        if element == reflection.TYPE_FLOAT:
            return "float"
        if element == reflection.TYPE_INT:
            return "int"
        if element == reflection.TYPE_UINT:
            return "unsigned int"
        if element == reflection.TYPE_VEC2:
            return "Vec2f"
        if element == reflection.TYPE_VEC3:
            return "Vec3f"
        if element == reflection.TYPE_VEC4:
            return "Vec4f"
        if element == reflection.TYPE_IVEC2:
            return "Vec2i"
        if element == reflection.TYPE_IVEC3:
            return "Vec3i"
        if element == reflection.TYPE_IVEC4:
            return "Vec4i"
        if element == reflection.TYPE_UVEC2:
            return "Vec2u"
        if element == reflection.TYPE_UVEC3:
            return "Vec3u"
        if element == reflection.TYPE_UVEC4:
            return "Vec4u"
        if element == reflection.TYPE_MAT2:
            return "Mat2x2f"
        if element == reflection.TYPE_MAT3:
            return "Mat3x3f"
        if element == reflection.TYPE_MAT4:
            return "Mat4x4f"
        if isinstance(element, reflection.Struct):
            return f"struct {element.name}"
        return ""

    def emit_struct(self, struct):
        assert isinstance(struct, reflection.Struct)

        generated = f"struct {struct.name}""{\n"

        for field in struct.fields:
            generated += f"{self.emit_type_decl(field.decl_type)} {field.name}"
            generated += f"[{field.array_size}];\n" if field.is_array() else ";\n"

        generated += "};\n"

        return generated

    def emit_buffer(self, buffer):
        assert isinstance(buffer, reflection.Buffer)

        buffer_structure = self.emit_struct(buffer.struct) + "\n"

        name = buffer.name.upper()
        binding = buffer.binding
        buffer_info = f"static constexpr const int {name}_SET = {binding.set_num};\n" \
                      f"static constexpr const int {name}_SLOT = {binding.slot_num};\n" \
                      f"static constexpr const auto {name}_LOC = {binding.to_gfx_loc()};\n" \
                      f"static constexpr const char {name}_NAME[] = \"{buffer.name}\";\n"

        return buffer_structure + buffer_info


def make_shader_name(shader_file, lang):
    left, right = shader_file.split(".")
    return f"{left}_{lang}_{right}"


def make_file_name(shader_file, lang, directory, extension):
    return directory / f"{PREFIX}{make_shader_name(shader_file, lang)}.{extension}"


def read_file(file_path):
    with open(file_path, "r") as file:
        return file.readlines()


def process_file(file_path, included):
    content = read_file(DIR_SHADERS / file_path)
    output = []

    for line in content:
        if line == '\n':
            continue
        if line.startswith('/*'):
            continue
        if line.startswith('#include '):
            include_file = line.replace('#include ', '').replace('"', '').replace('\n', '')
            if include_file not in included:
                included.add(include_file)
                output += process_file(include_file, included)
            continue

        output.append(line)

    output.append('\n')
    return output


def process_general(generator, shader, lang, dir_build):
    for shader_file in shader.files:
        generated_code = ""
        generated_code += generator.run()
        generated_code += '\n'
        generated_code += "".join(process_file(shader_file, set()))

        with open(make_file_name(shader_file, lang, DIR_GENERATED, 'hpp'), "w") as file:
            file.write(LICENSE_HEADER)
            file.write('\n')
            file.write(SIGNATURE)
            file.write('\n')
            file.write(CXX_PRAGMA)
            file.write('\n')
            file.write(CXX_INCLUDES)
            file.write('\n')
            file.write(f"namespace {CXX_NAMESPACE}""{\n")
            file.write('\n')
            file.write(f"static const char source_{make_shader_name(shader_file, lang)}[] = R\"(\n")
            file.write(generated_code)
            file.write("\n)\";\n")
            file.write("}\n")

        if dir_build:
            with open(make_file_name(shader_file, lang, dir_build, 'glsl'), 'w') as file:
                file.write(generated_code)


def process_vk(shader, dir_build):
    process_general(CodeGeneratorGlslVk450(shader), shader, 'vk450', dir_build)


def process_gl(shader, dir_build):
    process_general(CodeGeneratorGlslGl410(shader), shader, 'gl410', dir_build)


def process_cxx(shader):
    with open(DIR_GENERATED / f"{PREFIX}{shader.name}_reflection.hpp", "w") as file:
        file.write(LICENSE_HEADER)
        file.write('\n')
        file.write(SIGNATURE)
        file.write('\n')
        file.write(CXX_PRAGMA)
        file.write('\n')
        file.write(CXX_INCLUDES)
        file.write('\n')
        file.write(f"namespace {CXX_NAMESPACE}""{\n")
        file.write('\n')
        file.write(f"struct Shader{shader.cls}""{\n")
        file.write(f"static constexpr const char NAME[] = \"{shader.name}\";\n")
        file.write(f"static constexpr const char CLS[] = \"{shader.cls}\";\n")
        file.write(f"static constexpr int NUM_FILES = {int(len(shader.files))};\n")
        file.write(f"static constexpr int NUM_CONSTS = {int(len(shader.constants))};\n")
        file.write(f"static constexpr int NUM_SAMPLERS = {int(len(shader.samplers))};\n")
        file.write(f"static constexpr int NUM_BUFFERS = {int(len(shader.buffers))};\n")
        file.write('\n')
        file.write(CodeGeneratorCxx(shader).run())
        file.write("};\n\n")
        file.write("}\n")


def main():
    parser = argparse.ArgumentParser('Reflection generator for engine shader files')
    parser.add_argument("--mode", help="what to generate (all,vk,gl,cxx)", default="all")
    parser.add_argument("--build", help="path to a build of project to output shaders for hot-reload_shaders",
                        default=None)
    args = parser.parse_args()

    dir_build = None
    to_generate = ['vk', 'gl', 'cxx'] if 'all' in args.mode else args.mode.split(",")
    print(f"generate for {to_generate}")

    os.makedirs(DIR_GENERATED, exist_ok=True)
    print(f"output generated shaders for engine into {DIR_GENERATED}")

    if args.build:
        dir_build = DIR_ROOT / args.build / 'shaders'
        os.makedirs(dir_build, exist_ok=True)
        print(f"output generated shaders for hot-reload_shaders to {dir_build}")

    for i, shader in enumerate(SHADERS_LIST):
        print(f"[{i + 1}/{len(SHADERS_LIST)}] process shader {shader.name}")

        if 'vk' in to_generate:
            process_vk(shader, dir_build)
        if 'gl' in to_generate:
            process_gl(shader, dir_build)
        if 'cxx' in to_generate:
            process_cxx(shader)


if __name__ == '__main__':
    main()
